### Renaming schema fields
- allows specific fields in the schema to be renamed
- the field values in input rows are not changed
- can be used to rename fields generated by other transforms to make them more usable
- nested fields can also be renamed using the field-selection syntax
![[Pasted image 20230531170456.png]]
## Converting b/w types
- Beam can automatically convert b/w diff Java types
	- as long as those types have equivalent schemas
- one way to do this is by using Convert transform
![[Pasted image 20230531170809.png]]
- Beam will validate that the inferred schema for PurchasePojo matches that of the input PCollection
	- will then cast the PCol to a PCol\<PurchasePojo\>
- since the Row class can support any schema, any PColl with schema can be cast to a PColl of rows
![[Pasted image 20230531171448.png]]
- if the source type is a single-field schema, Convert will also convert to the type of the field if asked
	- effectively unboxing the row
	- in the below example, a schema with a single INT64 field is converted to long
![[Pasted image 20230531171640.png]]
- in all cases, type checking is done at pp graph construction
	- if the types do not match the schema then the pipeline will fail to launch
	- actual type and schema can be diff
		- when incompatible, error thrown

## Schemas in ParDo
- a PColl with a schema can apply a ParDo
	- just like any other PCollection
	- beam runner is aware of schemas when applying ParDo
		- which enables additional functionality
#### Input conversion
- since Beam knows the schema of the source PColl
	- it can automatically convert the elements to any Java type for which a matching schema is known
#### Input Selection
- since the input has a schema, we can also automatically select specific fields to process in the DoFn

## Data encoding and type safety
- when beam runners execute our pipeline, they often need to materialize the intermediate data in our PColls
	- which requires converting elements to and from byte strings
- Beam SDKs use objects called Coders to describe how the elements of a given PColl may be encoded and decoded
	- coders are unrelated to parsing or formatting data when interacting with external data or sinks
	- such parsing should be done using transforms like ParDO or MapElements
- Coder class provides the methods for enc and decoding
	- python available
	- there are a num of Coders subclasses that work with a variety of std py types
		- tuple, iterable
- coders do not necessarily have a 1:1 relationship with types
	- int might have multiple coders
	- i/p and o/p data can use diff int coders